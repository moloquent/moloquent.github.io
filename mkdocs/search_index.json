{
    "docs": [
        {
            "location": "/master/",
            "text": "Moloquent\n#\n\n\nAn \nEloquent\n model and Query builder with support for MongoDB, using the original \nLaravel\n API.\n\nThis library extends the original Laravel classes, so it uses exactly the same methods.  \n\n\n\n\n\n\n\n\n\n\nInstallation\n#\n\n\nMake sure you have the MongoDB PHP driver installed.\nYou can find installation instructions at \n\nhttp://php.net/manual/en/mongodb.installation.php\n.\n\n\nInstallation using composer\n#\n\n\nBleeding Edge\n#\n\n\nWe try our best to commit well tested and stable commits to this branch and every commit is already unit tested.\nIf you want to get always bleeding edge version use this:\n\n\ncomposer require moloquent/moloquent:dev-master\n\n\n\n\nStable\n#\n\n\ncomposer require moloquent/moloquent\n\n\n\n\nFor Laravel >= 5.0\n#\n\n\nAdd the service provider in \nconfig/app.php\n:\n\n\nMoloquent\\MongodbServiceProvider::class,\n\n\n\n\nAlias\n#\n\n\nYou may also register an alias for the MongoDB model by adding the following to the alias array in \nconfig/app.php\n:\n\n\n'Moloquent'       => 'Moloquent\\Eloquent\\Model',\n\n\n\n\nThis will allow you to use the registered alias like:\n\n\nclass MyModel extends Moloquent {}\n\n\n\n\nFor \nLumen\n#\n\n\nAdd the service provider in \nbootstrap/app.php\n. In this file, you will also need to enable Eloquent. You must however ensure that your call to \n$app->withEloquent();\n is \nbelow\n where you have registered the \nMongodbServiceProvider\n:\n\n\n$app->register('Moloquent\\MongodbServiceProvider');\n$app->withEloquent();\n\n\n\n\nThe service provider will register a mongodb database extension with the original database manager. There is no need to register additional facades or objects. When using mongodb connections, Laravel will automatically provide you with the corresponding mongodb objects.\n\n\nFor usage outside Laravel, check out the \nCapsule manager\n and add:\n\n\n$capsule->getDatabaseManager()->extend('mongodb', function($config)\n{\n    return new \\Moloquent\\Connection($config);\n});\n\n\n\n\nConfiguration\n#\n\n\nChange your default database connection name in \nconfig/database.php\n:\n\n\n'default' => env('DB_CONNECTION', 'mongodb'),\n\n\n\n\nAnd add a new mongodb connection:\n\n\n'mongodb' => [\n    'driver'   => 'mongodb',\n    'host'     => env('DB_HOST', 'localhost'),\n    'port'     => env('DB_PORT', 27017),\n    'database' => env('DB_DATABASE'),\n    'username' => env('DB_USERNAME'),\n    'password' => env('DB_PASSWORD'),\n    'use_mongo_id' => false,\n    'options' => [\n        'db' => 'admin', // Sets the authentication database required by mongo 3\n        //['replicaSet' => 'replicaSetName'], // Connect to multiple servers or replica sets\n    ]\n],\n\n\n\n\nAuth\n#\n\n\nIf you want to use Laravel's native Auth functionality, register this included service provider:\n\n\nMoloquent\\Auth\\PasswordResetServiceProvider::class,\n\n\n\n\nThis service provider will slightly modify the internal DatabaseReminderRepository to add support for MongoDB based password reminders. If you don't use password reminders, you don't have to register this service provider and everything else should work just fine.\n\n\nQueues\n#\n\n\nAdd the service provider in \nconfig/app.php\n: \n\n\nMoloquent\\MongodbQueueServiceProvider::class,\n\n\n\n\nIf you want to use MongoDB as your database backend, change the the driver in \nconfig/queue.php\n:\n\n\n'connections' => [\n    'database' => [\n        'driver' => 'mongodb',\n        'table'  => 'jobs',\n        'queue'  => 'default',\n        'expire' => 60,\n    ],\n\n\n\n\nIf you want to use MongoDB to handle failed jobs, change the database in \nconfig/queue.php\n:\n\n\n'failed' => [\n    'database' => 'mongodb',\n    'table'    => 'failed_jobs',\n    ],\n\n\n\n\nPassport\n#\n\n\ndev-master only\n\nIn order to use laravel passport with your models, add \nPassportServiceProvider\n service provider in \nconfig/app.php\n: \n\n\nMoloquent\\Passport\\PassportServiceProvider::class,",
            "title": "Getting Started"
        },
        {
            "location": "/master/#moloquent",
            "text": "An  Eloquent  model and Query builder with support for MongoDB, using the original  Laravel  API. \nThis library extends the original Laravel classes, so it uses exactly the same methods.",
            "title": "Moloquent"
        },
        {
            "location": "/master/#installation",
            "text": "Make sure you have the MongoDB PHP driver installed.\nYou can find installation instructions at  http://php.net/manual/en/mongodb.installation.php .",
            "title": "Installation"
        },
        {
            "location": "/master/#installation-using-composer",
            "text": "",
            "title": "Installation using composer"
        },
        {
            "location": "/master/#bleeding-edge",
            "text": "We try our best to commit well tested and stable commits to this branch and every commit is already unit tested.\nIf you want to get always bleeding edge version use this:  composer require moloquent/moloquent:dev-master",
            "title": "Bleeding Edge"
        },
        {
            "location": "/master/#stable",
            "text": "composer require moloquent/moloquent",
            "title": "Stable"
        },
        {
            "location": "/master/#for-laravel-50",
            "text": "Add the service provider in  config/app.php :  Moloquent\\MongodbServiceProvider::class,",
            "title": "For Laravel &gt;= 5.0"
        },
        {
            "location": "/master/#alias",
            "text": "You may also register an alias for the MongoDB model by adding the following to the alias array in  config/app.php :  'Moloquent'       => 'Moloquent\\Eloquent\\Model',  This will allow you to use the registered alias like:  class MyModel extends Moloquent {}",
            "title": "Alias"
        },
        {
            "location": "/master/#for-lumen",
            "text": "Add the service provider in  bootstrap/app.php . In this file, you will also need to enable Eloquent. You must however ensure that your call to  $app->withEloquent();  is  below  where you have registered the  MongodbServiceProvider :  $app->register('Moloquent\\MongodbServiceProvider');\n$app->withEloquent();  The service provider will register a mongodb database extension with the original database manager. There is no need to register additional facades or objects. When using mongodb connections, Laravel will automatically provide you with the corresponding mongodb objects.  For usage outside Laravel, check out the  Capsule manager  and add:  $capsule->getDatabaseManager()->extend('mongodb', function($config)\n{\n    return new \\Moloquent\\Connection($config);\n});",
            "title": "For Lumen"
        },
        {
            "location": "/master/#configuration",
            "text": "Change your default database connection name in  config/database.php :  'default' => env('DB_CONNECTION', 'mongodb'),  And add a new mongodb connection:  'mongodb' => [\n    'driver'   => 'mongodb',\n    'host'     => env('DB_HOST', 'localhost'),\n    'port'     => env('DB_PORT', 27017),\n    'database' => env('DB_DATABASE'),\n    'username' => env('DB_USERNAME'),\n    'password' => env('DB_PASSWORD'),\n    'use_mongo_id' => false,\n    'options' => [\n        'db' => 'admin', // Sets the authentication database required by mongo 3\n        //['replicaSet' => 'replicaSetName'], // Connect to multiple servers or replica sets\n    ]\n],",
            "title": "Configuration"
        },
        {
            "location": "/master/#auth",
            "text": "If you want to use Laravel's native Auth functionality, register this included service provider:  Moloquent\\Auth\\PasswordResetServiceProvider::class,  This service provider will slightly modify the internal DatabaseReminderRepository to add support for MongoDB based password reminders. If you don't use password reminders, you don't have to register this service provider and everything else should work just fine.",
            "title": "Auth"
        },
        {
            "location": "/master/#queues",
            "text": "Add the service provider in  config/app.php :   Moloquent\\MongodbQueueServiceProvider::class,  If you want to use MongoDB as your database backend, change the the driver in  config/queue.php :  'connections' => [\n    'database' => [\n        'driver' => 'mongodb',\n        'table'  => 'jobs',\n        'queue'  => 'default',\n        'expire' => 60,\n    ],  If you want to use MongoDB to handle failed jobs, change the database in  config/queue.php :  'failed' => [\n    'database' => 'mongodb',\n    'table'    => 'failed_jobs',\n    ],",
            "title": "Queues"
        },
        {
            "location": "/master/#passport",
            "text": "dev-master only \nIn order to use laravel passport with your models, add  PassportServiceProvider  service provider in  config/app.php :   Moloquent\\Passport\\PassportServiceProvider::class,",
            "title": "Passport"
        },
        {
            "location": "/master/basic/",
            "text": "Eloquent\n#\n\n\nThis package includes a MongoDB enabled Eloquent class that you can use to define models for corresponding collections.\n\n\nuse Moloquent\\Eloquent\\Model as Eloquent;\n\nclass User extends Eloquent {}\n\n\n\n\nNote that we did not tell Eloquent which collection to use for the \nUser\n model. Just like the original Eloquent, the lower-case, plural name of the class will be used as the table name unless another name is explicitly specified. You may specify a custom collection (alias for table) by defining a \ncollection\n property on your model:\n\n\nuse Moloquent\\Eloquent\\Model as Eloquent;\n\nclass User extends Eloquent {\n\n    protected $collection = 'users_collection';\n\n}\n\n\n\n\nNOTE:\n Eloquent will also assume that each collection has a primary key column named id. You may define a \nprimaryKey\n property to override this convention. Likewise, you may define a \nconnection\n property to override the name of the database connection that should be used when utilizing the model.\n\n\nuse Moloquent\\Eloquent\\Model as Eloquent;\n\nclass MyModel extends Eloquent {\n\n    protected $connection = 'mongodb';\n\n}\n\n\n\n\nEverything else (should) work just like the original Eloquent model. Read more about the Eloquent on http://laravel.com/docs/eloquent\n\n\nRetrieving All Models\n#\n\n\n$users = User::all();\n\n\n\n\nRetrieving By Primary Key\n#\n\n\n$user = User::find('517c43667db388101e00000f');\n\n\n\n\nInserts, updates and deletes\n#\n\n\nInserting, updating and deleting records works just like the original Eloquent.\n\n\nSaving a new model\n#\n\n\n$user = new User;\n$user->name = 'John';\n$user->save();\n\n\n\n\nYou may also use the create method to save a new model in a single line:\n\n\nUser::create(['name' => 'John']);\n\n\n\n\nUpdating a model\n#\n\n\nTo update a model, you may retrieve it, change an attribute, and use the save method.\n\n\n$user = User::first();\n$user->email = 'john@foo.com';\n$user->save();\n\n\n\n\nThere is also support for upsert operations\n\n\nDeleting a model\n#\n\n\nTo delete a model, simply call the delete method on the instance:\n\n\n$user = User::first();\n$user->delete();\n\n\n\n\nOr deleting a model by its key:\n\n\nUser::destroy('517c43667db388101e00000f');\n\n\n\n\nFor more information about model manipulation, check \nHere\n.\n\n\nWheres\n#\n\n\n$users = User::where('votes', '>', 100)->take(10)->get();\n\n\n\n\nOr Statements\n#\n\n\n$users = User::where('votes', '>', 100)->orWhere('name', 'John')->get();\n\n\n\n\nAnd Statements\n#\n\n\n$users = User::where('votes', '>', 100)->where('name', '=', 'John')->get();\n\n\n\n\nWhere In With An Array\n#\n\n\n$users = User::whereIn('age', [16, 18, 20])->get();\n\n\n\n\nWhen using \nwhereNotIn\n objects will be returned if the field is non existent. Combine with \nwhereNotNull('age')\n to leave out those documents.\n\n\nWhere Between\n#\n\n\n$users = User::whereBetween('votes', [1, 100])->get();\n\n\n\n\nWhere null\n#\n\n\n$users = User::whereNull('updated_at')->get();\n\n\n\n\nWhere Like\n#\n\n\n$user = Comment::where('body', 'like', '%spam%')->get();\n\n\n\n\nExists\n#\n\n\nMatches documents that have the specified field.\n\n\nUser::where('age', 'exists', true)->get();\n\n\n\n\nAll\n#\n\n\nMatches arrays that contain all elements specified in the query.\n\n\nUser::where('roles', 'all', ['moderator', 'author'])->get();\n\n\n\n\nSize\n#\n\n\nSelects documents if the array field is a specified size.\n\n\nUser::where('tags', 'size', 3)->get();\n\n\n\n\nRegex\n#\n\n\nSelects documents where values match a specified regular expression.\n\n\nUser::where('name', 'regex', new \\MongoDB\\BSON\\Regex(\"/.*doe/i\"))->get();\n\n\n\n\nNOTE:\n you can also use the Laravel regexp operations. These are a bit more flexible and will automatically convert your regular expression string to a \nMongoDB\\BSON\\Regex\n object.\n\n\nUser::where('name', 'regexp', '/.*doe/i'))->get();\n\n\n\n\nAnd the inverse:\n\n\nUser::where('name', 'not regexp', '/.*doe/i'))->get();\n\n\n\n\nType\n#\n\n\nSelects documents if a field is of the specified type.\nFor more information check \nHere\n.\n\n\nUser::where('age', 'type', 2)->get();\n\n\n\n\nMod\n#\n\n\nPerforms a modulo operation on the value of a field and selects documents with a specified result.\n\n\nUser::where('age', 'mod', [10, 0])->get();\n\n\n\n\nComplex Wheres\n#\n\n\n$users = User::where('name', '=', 'John')->orWhere(function($query) {\n        $query->where('votes', '>', 100)\n              ->where('title', '<>', 'Admin');\n    })\n    ->get();\n\n\n\n\nRaw Where\n#\n\n\nThese expressions will be injected directly into the query.\n\n\nUser::whereRaw(['age' => ['$gt' => 30, '$lt' => 40] ])->get();\n\n\n\n\nMatches documents that satisfy a JavaScript expression.\nFor more information check \nHere\n.",
            "title": "Basic Usage"
        },
        {
            "location": "/master/basic/#eloquent",
            "text": "This package includes a MongoDB enabled Eloquent class that you can use to define models for corresponding collections.  use Moloquent\\Eloquent\\Model as Eloquent;\n\nclass User extends Eloquent {}  Note that we did not tell Eloquent which collection to use for the  User  model. Just like the original Eloquent, the lower-case, plural name of the class will be used as the table name unless another name is explicitly specified. You may specify a custom collection (alias for table) by defining a  collection  property on your model:  use Moloquent\\Eloquent\\Model as Eloquent;\n\nclass User extends Eloquent {\n\n    protected $collection = 'users_collection';\n\n}  NOTE:  Eloquent will also assume that each collection has a primary key column named id. You may define a  primaryKey  property to override this convention. Likewise, you may define a  connection  property to override the name of the database connection that should be used when utilizing the model.  use Moloquent\\Eloquent\\Model as Eloquent;\n\nclass MyModel extends Eloquent {\n\n    protected $connection = 'mongodb';\n\n}  Everything else (should) work just like the original Eloquent model. Read more about the Eloquent on http://laravel.com/docs/eloquent",
            "title": "Eloquent"
        },
        {
            "location": "/master/basic/#retrieving-all-models",
            "text": "$users = User::all();",
            "title": "Retrieving All Models"
        },
        {
            "location": "/master/basic/#retrieving-by-primary-key",
            "text": "$user = User::find('517c43667db388101e00000f');",
            "title": "Retrieving By Primary Key"
        },
        {
            "location": "/master/basic/#inserts-updates-and-deletes",
            "text": "Inserting, updating and deleting records works just like the original Eloquent.",
            "title": "Inserts, updates and deletes"
        },
        {
            "location": "/master/basic/#saving-a-new-model",
            "text": "$user = new User;\n$user->name = 'John';\n$user->save();  You may also use the create method to save a new model in a single line:  User::create(['name' => 'John']);",
            "title": "Saving a new model"
        },
        {
            "location": "/master/basic/#updating-a-model",
            "text": "To update a model, you may retrieve it, change an attribute, and use the save method.  $user = User::first();\n$user->email = 'john@foo.com';\n$user->save();  There is also support for upsert operations",
            "title": "Updating a model"
        },
        {
            "location": "/master/basic/#deleting-a-model",
            "text": "To delete a model, simply call the delete method on the instance:  $user = User::first();\n$user->delete();  Or deleting a model by its key:  User::destroy('517c43667db388101e00000f');  For more information about model manipulation, check  Here .",
            "title": "Deleting a model"
        },
        {
            "location": "/master/basic/#wheres",
            "text": "$users = User::where('votes', '>', 100)->take(10)->get();",
            "title": "Wheres"
        },
        {
            "location": "/master/basic/#or-statements",
            "text": "$users = User::where('votes', '>', 100)->orWhere('name', 'John')->get();",
            "title": "Or Statements"
        },
        {
            "location": "/master/basic/#and-statements",
            "text": "$users = User::where('votes', '>', 100)->where('name', '=', 'John')->get();",
            "title": "And Statements"
        },
        {
            "location": "/master/basic/#where-in-with-an-array",
            "text": "$users = User::whereIn('age', [16, 18, 20])->get();  When using  whereNotIn  objects will be returned if the field is non existent. Combine with  whereNotNull('age')  to leave out those documents.",
            "title": "Where In With An Array"
        },
        {
            "location": "/master/basic/#where-between",
            "text": "$users = User::whereBetween('votes', [1, 100])->get();",
            "title": "Where Between"
        },
        {
            "location": "/master/basic/#where-null",
            "text": "$users = User::whereNull('updated_at')->get();",
            "title": "Where null"
        },
        {
            "location": "/master/basic/#where-like",
            "text": "$user = Comment::where('body', 'like', '%spam%')->get();",
            "title": "Where Like"
        },
        {
            "location": "/master/basic/#exists",
            "text": "Matches documents that have the specified field.  User::where('age', 'exists', true)->get();",
            "title": "Exists"
        },
        {
            "location": "/master/basic/#all",
            "text": "Matches arrays that contain all elements specified in the query.  User::where('roles', 'all', ['moderator', 'author'])->get();",
            "title": "All"
        },
        {
            "location": "/master/basic/#size",
            "text": "Selects documents if the array field is a specified size.  User::where('tags', 'size', 3)->get();",
            "title": "Size"
        },
        {
            "location": "/master/basic/#regex",
            "text": "Selects documents where values match a specified regular expression.  User::where('name', 'regex', new \\MongoDB\\BSON\\Regex(\"/.*doe/i\"))->get();  NOTE:  you can also use the Laravel regexp operations. These are a bit more flexible and will automatically convert your regular expression string to a  MongoDB\\BSON\\Regex  object.  User::where('name', 'regexp', '/.*doe/i'))->get();  And the inverse:  User::where('name', 'not regexp', '/.*doe/i'))->get();",
            "title": "Regex"
        },
        {
            "location": "/master/basic/#type",
            "text": "Selects documents if a field is of the specified type.\nFor more information check  Here .  User::where('age', 'type', 2)->get();",
            "title": "Type"
        },
        {
            "location": "/master/basic/#mod",
            "text": "Performs a modulo operation on the value of a field and selects documents with a specified result.  User::where('age', 'mod', [10, 0])->get();",
            "title": "Mod"
        },
        {
            "location": "/master/basic/#complex-wheres",
            "text": "$users = User::where('name', '=', 'John')->orWhere(function($query) {\n        $query->where('votes', '>', 100)\n              ->where('title', '<>', 'Admin');\n    })\n    ->get();",
            "title": "Complex Wheres"
        },
        {
            "location": "/master/basic/#raw-where",
            "text": "These expressions will be injected directly into the query.  User::whereRaw(['age' => ['$gt' => 30, '$lt' => 40] ])->get();  Matches documents that satisfy a JavaScript expression.\nFor more information check  Here .",
            "title": "Raw Where"
        },
        {
            "location": "/master/advanced/",
            "text": "Schema\n#\n\n\nThe database driver also has (limited) schema builder support. You can easily manipulate collections and set indexes:\n\n\nSchema::create('users', function($collection)\n{\n    $collection->index('name');\n\n    $collection->unique('email');\n});\n\n\n\n\nSupported operations are:\n\n\n\n\ncreate and drop\n\n\ncollection\n\n\nhasCollection\n\n\nindex and dropIndex (compound indexes supported as well)\n\n\nunique\n\n\nbackground, sparse, expire (MongoDB specific)\n\n\n\n\nAll other (unsupported) operations are implemented as dummy pass-through methods, because MongoDB does not use a predefined schema.\nRead more about the schema builder on \nhttp://laravel.com/docs/schema\n\n\nDates\n#\n\n\nEloquent allows you to work with Carbon/DateTime objects instead of MongoDate objects. Internally, these dates will be converted to MongoDate objects when saved to the database.\nIf you wish to use this functionality on non-default date fields you will need to manually specify them as described here: \nhttp://laravel.com/docs/eloquent#date-mutators\n\n\nExample:\n\n\nuse Moloquent\\Eloquent\\Model as Eloquent;\n\nclass User extends Eloquent {\n\n    protected $dates = ['birthday'];\n\n}\n\n\n\n\nWhich allows you to execute queries like:\n\n\n$users = User::where('birthday', '>', new DateTime('-18 years'))->get();\n\n\n\n\nSoft deleting\n#\n\n\nWhen soft deleting a model, it is not actually removed from your database. Instead, a \ndeleted_at\n timestamp is set on the record.\nTo enable soft deletes for a model, apply the \nSoftDeletes\n Trait to the model:\n\n\nuse Moloquent\\Eloquent\\SoftDeletes;\n\nclass User extends Eloquent {\n\n    use SoftDeletes;\n\n    protected $dates = ['deleted_at'];\n\n}\n\n\n\n\nFor more information check http://laravel.com/docs/eloquent#soft-deleting\n\n\nQuery Builder\n#\n\n\nThe database driver plugs right into the original query builder. When using mongodb connections, you will be able to build fluent queries to perform database operations. For your convenience, there is a \ncollection\n alias for \ntable\n as well as some additional mongodb specific operators/operations.\n\n\n$users = DB::collection('users')->get();\n\n$user = DB::collection('users')->where('name', 'John')->first();\n\n\n\n\nIf you did not change your default database connection, you will need to specify it when querying.\n\n\n$user = DB::connection('mongodb')->collection('users')->get();\n\n\n\n\nRead more about the query builder on http://laravel.com/docs/queries\n\n\nRaw Expressions\n#\n\n\nYou can also perform raw expressions on the internal MongoCollection object. If this is executed on the model class, it will return a collection of models. If this is executed on the query builder, it will return the original response.\n\n\n// Returns a collection of User models.\n$models = User::raw(function($collection)\n{\n    return $collection->find();\n});\n\n// Returns the original MongoCursor.\n$cursor = DB::collection('users')->raw(function($collection)\n{\n    return $collection->find();\n});\n\n\n\n\nOptional: if you don't pass a closure to the raw method, the internal MongoCollection object will be accessible:\n\n\n$model = User::raw()->findOne(['age' => array('$lt' => 18]));\n\n\n\n\nThe internal MongoClient and MongoDB objects can be accessed like this:\n\n\n$client = DB::getMongoClient();\n$db = DB::getMongoDB();\n\n\n\n\nQuery Caching\n#\n\n\nYou may easily cache the results of a query using the remember method:\n\n\n$users = User::remember(10)->get();\n\n\n\n\nFrom: http://laravel.com/docs/queries#caching-queries\n\n\nQuery Logging\n#\n\n\nBy default, Laravel keeps a log in memory of all queries that have been run for the current request. However, in some cases, such as when inserting a large number of rows, this can cause the application to use excess memory. To disable the log, you may use the \ndisableQueryLog\n method:\n\n\nDB::connection()->disableQueryLog();\n\n\n\n\nFrom: http://laravel.com/docs/database#query-logging\n\n\nOrder By\n#\n\n\n$users = User::orderBy('name', 'desc')->get();\n\n\n\n\nOffset & Limit\n#\n\n\n$users = User::skip(10)->take(5)->get();\n\n\n\n\nDistinct\n#\n\n\nDistinct requires a field for which to return the distinct values.\n\n\n$users = User::distinct()->get(['name']);\n// or\n$users = User::distinct('name')->get();\n\n\n\n\nDistinct can be combined with \nwhere\n:\n\n\n$users = User::where('active', true)->distinct('name')->get();\n\n\n\n\nGroup By\n#\n\n\nSelected columns that are not grouped will be aggregated with the $last function.\n\n\n$users = Users::groupBy('title')->get(['title', 'name']);\n\n\n\n\nAggregation\n#\n\n\n$total = Order::count();\n$price = Order::max('price');\n$price = Order::min('price');\n$price = Order::avg('price');\n$total = Order::sum('price');\n\n\n\n\nAggregations can be combined with \nwhere\n:\n\n\n$sold = Orders::where('sold', true)->sum('price');\n\n\n\n\nMongoDB specific operations\n#\n\n\nCursor timeout\n#\n\n\nTo prevent MongoCursorTimeout exceptions, you can manually set a timeout value that will be applied to the cursor:\n\n\nDB::collection('users')->timeout(-1)->get();\n\n\n\n\nUpsert\n#\n\n\nUpdate or insert a document. Additional options for the update method are passed directly to the native update method.\n\n\nDB::collection('users')->where('name', 'John')\n                       ->update($data, ['upsert' => true]);\n\n\n\n\nProjections\n#\n\n\nYou can apply projections to your queries using the \nproject\n method.\n\n\nDB::collection('items')->project(['tags' => array('$slice' => 1]))->get();\n\n\n\n\nProjections with Pagination\n#\n\n\n$limit = 25;\n$projections = ['id', 'name'];\nDB::collection('items')->paginate($limit, $projections);\n\n\n\n\nPush\n#\n\n\nAdd an items to an array.\n\n\nDB::collection('users')->where('name', 'John')->push('items', 'boots');\nDB::collection('users')->where('name', 'John')->push('messages', ['from' => 'Jane Doe', 'message' => 'Hi John']);\n\n\n\n\nIf you don't want duplicate items, set the third parameter to \ntrue\n:\n\n\nDB::collection('users')->where('name', 'John')->push('items', 'boots', true);\n\n\n\n\nPull\n#\n\n\nRemove an item from an array.\n\n\nDB::collection('users')->where('name', 'John')->pull('items', 'boots');\nDB::collection('users')->where('name', 'John')->pull('messages', ['from' => 'Jane Doe', 'message' => 'Hi John']);\n\n\n\n\nUnset\n#\n\n\nRemove one or more fields from a document.\n\n\nDB::collection('users')->where('name', 'John')->unset('note');\n\n\n\n\nYou can also perform an unset on a model.\n\n\n$user = User::where('name', 'John')->first();\n$user->unset('note');\n\n\n\n\nIncrementing or decrementing\n#\n\n\nPerform increments or decrements (default 1) on specified attributes:\n\n\nUser::where('name', 'John Doe')->increment('age');\nUser::where('name', 'Jaques')->decrement('weight', 50);\n\n\n\n\nThe number of updated objects is returned:\n\n\n$count = User->increment('age');\n\n\n\n\nYou may also specify additional columns to update:\n\n\nUser::where('age', '29')->increment('age', 1, ['group' => 'thirty something']);\nUser::where('bmi', 30)->decrement('bmi', 1, ['category' => 'overweight']);",
            "title": "Advanced"
        },
        {
            "location": "/master/advanced/#schema",
            "text": "The database driver also has (limited) schema builder support. You can easily manipulate collections and set indexes:  Schema::create('users', function($collection)\n{\n    $collection->index('name');\n\n    $collection->unique('email');\n});  Supported operations are:   create and drop  collection  hasCollection  index and dropIndex (compound indexes supported as well)  unique  background, sparse, expire (MongoDB specific)   All other (unsupported) operations are implemented as dummy pass-through methods, because MongoDB does not use a predefined schema.\nRead more about the schema builder on  http://laravel.com/docs/schema",
            "title": "Schema"
        },
        {
            "location": "/master/advanced/#dates",
            "text": "Eloquent allows you to work with Carbon/DateTime objects instead of MongoDate objects. Internally, these dates will be converted to MongoDate objects when saved to the database.\nIf you wish to use this functionality on non-default date fields you will need to manually specify them as described here:  http://laravel.com/docs/eloquent#date-mutators  Example:  use Moloquent\\Eloquent\\Model as Eloquent;\n\nclass User extends Eloquent {\n\n    protected $dates = ['birthday'];\n\n}  Which allows you to execute queries like:  $users = User::where('birthday', '>', new DateTime('-18 years'))->get();",
            "title": "Dates"
        },
        {
            "location": "/master/advanced/#soft-deleting",
            "text": "When soft deleting a model, it is not actually removed from your database. Instead, a  deleted_at  timestamp is set on the record.\nTo enable soft deletes for a model, apply the  SoftDeletes  Trait to the model:  use Moloquent\\Eloquent\\SoftDeletes;\n\nclass User extends Eloquent {\n\n    use SoftDeletes;\n\n    protected $dates = ['deleted_at'];\n\n}  For more information check http://laravel.com/docs/eloquent#soft-deleting",
            "title": "Soft deleting"
        },
        {
            "location": "/master/advanced/#query-builder",
            "text": "The database driver plugs right into the original query builder. When using mongodb connections, you will be able to build fluent queries to perform database operations. For your convenience, there is a  collection  alias for  table  as well as some additional mongodb specific operators/operations.  $users = DB::collection('users')->get();\n\n$user = DB::collection('users')->where('name', 'John')->first();  If you did not change your default database connection, you will need to specify it when querying.  $user = DB::connection('mongodb')->collection('users')->get();  Read more about the query builder on http://laravel.com/docs/queries",
            "title": "Query Builder"
        },
        {
            "location": "/master/advanced/#raw-expressions",
            "text": "You can also perform raw expressions on the internal MongoCollection object. If this is executed on the model class, it will return a collection of models. If this is executed on the query builder, it will return the original response.  // Returns a collection of User models.\n$models = User::raw(function($collection)\n{\n    return $collection->find();\n});\n\n// Returns the original MongoCursor.\n$cursor = DB::collection('users')->raw(function($collection)\n{\n    return $collection->find();\n});  Optional: if you don't pass a closure to the raw method, the internal MongoCollection object will be accessible:  $model = User::raw()->findOne(['age' => array('$lt' => 18]));  The internal MongoClient and MongoDB objects can be accessed like this:  $client = DB::getMongoClient();\n$db = DB::getMongoDB();",
            "title": "Raw Expressions"
        },
        {
            "location": "/master/advanced/#query-caching",
            "text": "You may easily cache the results of a query using the remember method:  $users = User::remember(10)->get();  From: http://laravel.com/docs/queries#caching-queries",
            "title": "Query Caching"
        },
        {
            "location": "/master/advanced/#query-logging",
            "text": "By default, Laravel keeps a log in memory of all queries that have been run for the current request. However, in some cases, such as when inserting a large number of rows, this can cause the application to use excess memory. To disable the log, you may use the  disableQueryLog  method:  DB::connection()->disableQueryLog();  From: http://laravel.com/docs/database#query-logging",
            "title": "Query Logging"
        },
        {
            "location": "/master/advanced/#order-by",
            "text": "$users = User::orderBy('name', 'desc')->get();",
            "title": "Order By"
        },
        {
            "location": "/master/advanced/#offset-limit",
            "text": "$users = User::skip(10)->take(5)->get();",
            "title": "Offset &amp; Limit"
        },
        {
            "location": "/master/advanced/#distinct",
            "text": "Distinct requires a field for which to return the distinct values.  $users = User::distinct()->get(['name']);\n// or\n$users = User::distinct('name')->get();  Distinct can be combined with  where :  $users = User::where('active', true)->distinct('name')->get();",
            "title": "Distinct"
        },
        {
            "location": "/master/advanced/#group-by",
            "text": "Selected columns that are not grouped will be aggregated with the $last function.  $users = Users::groupBy('title')->get(['title', 'name']);",
            "title": "Group By"
        },
        {
            "location": "/master/advanced/#aggregation",
            "text": "$total = Order::count();\n$price = Order::max('price');\n$price = Order::min('price');\n$price = Order::avg('price');\n$total = Order::sum('price');  Aggregations can be combined with  where :  $sold = Orders::where('sold', true)->sum('price');",
            "title": "Aggregation"
        },
        {
            "location": "/master/advanced/#mongodb-specific-operations",
            "text": "",
            "title": "MongoDB specific operations"
        },
        {
            "location": "/master/advanced/#cursor-timeout",
            "text": "To prevent MongoCursorTimeout exceptions, you can manually set a timeout value that will be applied to the cursor:  DB::collection('users')->timeout(-1)->get();",
            "title": "Cursor timeout"
        },
        {
            "location": "/master/advanced/#upsert",
            "text": "Update or insert a document. Additional options for the update method are passed directly to the native update method.  DB::collection('users')->where('name', 'John')\n                       ->update($data, ['upsert' => true]);",
            "title": "Upsert"
        },
        {
            "location": "/master/advanced/#projections",
            "text": "You can apply projections to your queries using the  project  method.  DB::collection('items')->project(['tags' => array('$slice' => 1]))->get();",
            "title": "Projections"
        },
        {
            "location": "/master/advanced/#projections-with-pagination",
            "text": "$limit = 25;\n$projections = ['id', 'name'];\nDB::collection('items')->paginate($limit, $projections);",
            "title": "Projections with Pagination"
        },
        {
            "location": "/master/advanced/#push",
            "text": "Add an items to an array.  DB::collection('users')->where('name', 'John')->push('items', 'boots');\nDB::collection('users')->where('name', 'John')->push('messages', ['from' => 'Jane Doe', 'message' => 'Hi John']);  If you don't want duplicate items, set the third parameter to  true :  DB::collection('users')->where('name', 'John')->push('items', 'boots', true);",
            "title": "Push"
        },
        {
            "location": "/master/advanced/#pull",
            "text": "Remove an item from an array.  DB::collection('users')->where('name', 'John')->pull('items', 'boots');\nDB::collection('users')->where('name', 'John')->pull('messages', ['from' => 'Jane Doe', 'message' => 'Hi John']);",
            "title": "Pull"
        },
        {
            "location": "/master/advanced/#unset",
            "text": "Remove one or more fields from a document.  DB::collection('users')->where('name', 'John')->unset('note');  You can also perform an unset on a model.  $user = User::where('name', 'John')->first();\n$user->unset('note');",
            "title": "Unset"
        },
        {
            "location": "/master/advanced/#incrementing-or-decrementing",
            "text": "Perform increments or decrements (default 1) on specified attributes:  User::where('name', 'John Doe')->increment('age');\nUser::where('name', 'Jaques')->decrement('weight', 50);  The number of updated objects is returned:  $count = User->increment('age');  You may also specify additional columns to update:  User::where('age', '29')->increment('age', 1, ['group' => 'thirty something']);\nUser::where('bmi', 30)->decrement('bmi', 1, ['category' => 'overweight']);",
            "title": "Incrementing or decrementing"
        },
        {
            "location": "/master/relations/",
            "text": "Relations\n#\n\n\nSupported relations are:\n\n\n\n\nhasOne\n\n\nhasMany\n\n\nbelongsTo\n\n\nbelongsToMany\n\n\nembedsOne\n\n\nembedsMany\n\n\n\n\nExample:\n\n\nuse Moloquent\\Eloquent\\Model as Eloquent;\n\nclass User extends Eloquent {\n\n    public function items()\n    {\n        return $this->hasMany('Item');\n    }\n\n}\n\n\n\n\nAnd the inverse relation:\n\n\nuse Moloquent\\Eloquent\\Model as Eloquent;\n\nclass Item extends Eloquent {\n\n    public function user()\n    {\n        return $this->belongsTo('User');\n    }\n\n}\n\n\n\n\nThe belongsToMany relation will not use a pivot \"table\", but will push id's to a \nrelated_ids\n attribute instead. This makes the second parameter for the belongsToMany method useless. If you want to define custom keys for your relation, set it to \nnull\n:\n\n\nuse Moloquent\\Eloquent\\Model as Eloquent;\n\nclass User extends Eloquent {\n\n    public function groups()\n    {\n        return $this->belongsToMany('Group', null, 'user_ids', 'group_ids');\n    }\n\n}\n\n\n\n\nOther relations are not yet supported, but may be added in the future. Read more about these relations on http://laravel.com/docs/eloquent#relationships\n\n\nEmbedsMany Relations\n#\n\n\nIf you want to embed models, rather than referencing them, you can use the \nembedsMany\n relation. This relation is similar to the \nhasMany\n relation, but embeds the models inside the parent object.\n\n\nREMEMBER\n: these relations return Eloquent collections, they don't return query builder objects!\n\n\nuse Moloquent\\Eloquent\\Model as Eloquent;\n\nclass User extends Eloquent {\n\n    public function books()\n    {\n        return $this->embedsMany('Book');\n    }\n\n}\n\n\n\n\nYou access the embedded models through the dynamic property:\n\n\n$books = User::first()->books;\n\n\n\n\nThe inverse relation is auto\nmagically\n available, you don't need to define this reverse relation.\n\n\n$user = $book->user;\n\n\n\n\nInserting and updating embedded models works similar to the \nhasMany\n relation:\n\n\n$book = new Book(['title' => 'A Game of Thrones']);\n\n$user = User::first();\n\n$book = $user->books()->save($book);\n// or\n$book = $user->books()->create(['title' => 'A Game of Thrones'])\n\n\n\n\nYou can update embedded models using their \nsave\n method (available since release 2.0.0):\n\n\n$book = $user->books()->first();\n\n$book->title = 'A Game of Thrones';\n\n$book->save();\n\n\n\n\nYou can remove an embedded model by using the \ndestroy\n method on the relation, or the \ndelete\n method on the model (available since release 2.0.0):\n\n\n$book = $user->books()->first();\n\n$book->delete();\n// or\n$user->books()->destroy($book);\n\n\n\n\nIf you want to add or remove an embedded model, without touching the database, you can use the \nassociate\n and \ndissociate\n methods. To eventually write the changes to the database, save the parent object:\n\n\n$user->books()->associate($book);\n\n$user->save();\n\n\n\n\nLike other relations, embedsMany assumes the local key of the relationship based on the model name. You can override the default local key by passing a second argument to the embedsMany method:\n\n\nreturn $this->embedsMany('Book', 'local_key');\n\n\n\n\nEmbedded relations will return a Collection of embedded items instead of a query builder. Check out the available operations here: https://laravel.com/docs/master/collections\n\n\nEmbedsOne Relations\n#\n\n\nThe embedsOne relation is similar to the EmbedsMany relation, but only embeds a single model.\n\n\nuse Moloquent\\Eloquent\\Model as Eloquent;\n\nclass Book extends Eloquent {\n\n    public function author()\n    {\n        return $this->embedsOne('Author');\n    }\n\n}\n\n\n\n\nYou access the embedded models through the dynamic property:\n\n\n$author = Book::first()->author;\n\n\n\n\nInserting and updating embedded models works similar to the \nhasOne\n relation:\n\n\n$author = new Author(['name' => 'John Doe']);\n\n$book = Books::first();\n\n$author = $book->author()->save($author);\n// or\n$author = $book->author()->create(['name' => 'John Doe']);\n\n\n\n\nYou can update the embedded model using the \nsave\n method (available since release 2.0.0):\n\n\n$author = $book->author;\n\n$author->name = 'Jane Doe';\n$author->save();\n\n\n\n\nYou can replace the embedded model with a new model like this:\n\n\n$newAuthor = new Author(['name' => 'Jane Doe']);\n$book->author()->save($newAuthor);\n\n\n\n\nMySQL Relations\n#\n\n\nIf you're using a hybrid MongoDB and SQL setup, you're in luck! The model will automatically return a MongoDB- or SQL-relation based on the type of the related model. Of course, if you want this functionality to work both ways, your SQL-models will need use the \nMoloquent\\Eloquent\\HybridRelations\n trait. Note that this functionality only works for hasOne, hasMany and belongsTo relations.\n\n\nExample SQL-based User model:\n\n\nuse Moloquent\\Eloquent\\HybridRelations;\n\nclass User extends Eloquent {\n\n    use HybridRelations;\n\n    protected $connection = 'mysql';\n\n    public function messages()\n    {\n        return $this->hasMany('Message');\n    }\n\n}\n\n\n\n\nAnd the Mongodb-based Message model:\n\n\nuse Moloquent\\Eloquent\\Model as Eloquent;\n\nclass Message extends Eloquent {\n\n    protected $connection = 'mongodb';\n\n    public function user()\n    {\n        return $this->belongsTo('User');\n    }\n\n}",
            "title": "Relations"
        },
        {
            "location": "/master/relations/#relations",
            "text": "Supported relations are:   hasOne  hasMany  belongsTo  belongsToMany  embedsOne  embedsMany   Example:  use Moloquent\\Eloquent\\Model as Eloquent;\n\nclass User extends Eloquent {\n\n    public function items()\n    {\n        return $this->hasMany('Item');\n    }\n\n}  And the inverse relation:  use Moloquent\\Eloquent\\Model as Eloquent;\n\nclass Item extends Eloquent {\n\n    public function user()\n    {\n        return $this->belongsTo('User');\n    }\n\n}  The belongsToMany relation will not use a pivot \"table\", but will push id's to a  related_ids  attribute instead. This makes the second parameter for the belongsToMany method useless. If you want to define custom keys for your relation, set it to  null :  use Moloquent\\Eloquent\\Model as Eloquent;\n\nclass User extends Eloquent {\n\n    public function groups()\n    {\n        return $this->belongsToMany('Group', null, 'user_ids', 'group_ids');\n    }\n\n}  Other relations are not yet supported, but may be added in the future. Read more about these relations on http://laravel.com/docs/eloquent#relationships",
            "title": "Relations"
        },
        {
            "location": "/master/relations/#embedsmany-relations",
            "text": "If you want to embed models, rather than referencing them, you can use the  embedsMany  relation. This relation is similar to the  hasMany  relation, but embeds the models inside the parent object.  REMEMBER : these relations return Eloquent collections, they don't return query builder objects!  use Moloquent\\Eloquent\\Model as Eloquent;\n\nclass User extends Eloquent {\n\n    public function books()\n    {\n        return $this->embedsMany('Book');\n    }\n\n}  You access the embedded models through the dynamic property:  $books = User::first()->books;  The inverse relation is auto magically  available, you don't need to define this reverse relation.  $user = $book->user;  Inserting and updating embedded models works similar to the  hasMany  relation:  $book = new Book(['title' => 'A Game of Thrones']);\n\n$user = User::first();\n\n$book = $user->books()->save($book);\n// or\n$book = $user->books()->create(['title' => 'A Game of Thrones'])  You can update embedded models using their  save  method (available since release 2.0.0):  $book = $user->books()->first();\n\n$book->title = 'A Game of Thrones';\n\n$book->save();  You can remove an embedded model by using the  destroy  method on the relation, or the  delete  method on the model (available since release 2.0.0):  $book = $user->books()->first();\n\n$book->delete();\n// or\n$user->books()->destroy($book);  If you want to add or remove an embedded model, without touching the database, you can use the  associate  and  dissociate  methods. To eventually write the changes to the database, save the parent object:  $user->books()->associate($book);\n\n$user->save();  Like other relations, embedsMany assumes the local key of the relationship based on the model name. You can override the default local key by passing a second argument to the embedsMany method:  return $this->embedsMany('Book', 'local_key');  Embedded relations will return a Collection of embedded items instead of a query builder. Check out the available operations here: https://laravel.com/docs/master/collections",
            "title": "EmbedsMany Relations"
        },
        {
            "location": "/master/relations/#embedsone-relations",
            "text": "The embedsOne relation is similar to the EmbedsMany relation, but only embeds a single model.  use Moloquent\\Eloquent\\Model as Eloquent;\n\nclass Book extends Eloquent {\n\n    public function author()\n    {\n        return $this->embedsOne('Author');\n    }\n\n}  You access the embedded models through the dynamic property:  $author = Book::first()->author;  Inserting and updating embedded models works similar to the  hasOne  relation:  $author = new Author(['name' => 'John Doe']);\n\n$book = Books::first();\n\n$author = $book->author()->save($author);\n// or\n$author = $book->author()->create(['name' => 'John Doe']);  You can update the embedded model using the  save  method (available since release 2.0.0):  $author = $book->author;\n\n$author->name = 'Jane Doe';\n$author->save();  You can replace the embedded model with a new model like this:  $newAuthor = new Author(['name' => 'Jane Doe']);\n$book->author()->save($newAuthor);",
            "title": "EmbedsOne Relations"
        },
        {
            "location": "/master/relations/#mysql-relations",
            "text": "If you're using a hybrid MongoDB and SQL setup, you're in luck! The model will automatically return a MongoDB- or SQL-relation based on the type of the related model. Of course, if you want this functionality to work both ways, your SQL-models will need use the  Moloquent\\Eloquent\\HybridRelations  trait. Note that this functionality only works for hasOne, hasMany and belongsTo relations.  Example SQL-based User model:  use Moloquent\\Eloquent\\HybridRelations;\n\nclass User extends Eloquent {\n\n    use HybridRelations;\n\n    protected $connection = 'mysql';\n\n    public function messages()\n    {\n        return $this->hasMany('Message');\n    }\n\n}  And the Mongodb-based Message model:  use Moloquent\\Eloquent\\Model as Eloquent;\n\nclass Message extends Eloquent {\n\n    protected $connection = 'mongodb';\n\n    public function user()\n    {\n        return $this->belongsTo('User');\n    }\n\n}",
            "title": "MySQL Relations"
        }
    ]
}